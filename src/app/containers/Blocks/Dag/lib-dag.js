/* auto-generated by rollup at Thu Jan 07 2021 12:22:14 GMT+0800 (China Standard Time), DO NOT touch */
const RENDER_SIZE = 30;
const MAX_BUFFER_SIZE = 25;
const MIN_BUFFER_SIZE = 15;

const INIT_EPOCH_WIDTH = 40;
const PIVOT_R = [11, 14];
const NON_PIVOT_R = [6, 6];

const MAX_PIVOT_R = PIVOT_R[1];
const MAX_NON_PIVOT_R = NON_PIVOT_R[1];

const TITLE_FONT = '12px bold';
const TXT_FONT = '10px normal';

function scaleLinear() {
  let domain, range, clamp;
  function scale(v) {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    if (clamp) {
      const max = d0 <= d1 ? d1 : d0;
      const min = d0 <= d1 ? d0 : d1;
      v = Math.max(min, Math.min(max, v));
    }
    return r0 + ((r1 - r0) * (v - d0)) / (d1 - d0);
  }
  scale.domain = function (v) {
    // eslint-disable-next-line no-sequences
    return v ? ((domain = v), scale) : domain;
  };
  scale.range = function (v) {
    // eslint-disable-next-line no-sequences
    return v ? ((range = v), scale) : range;
  };
  scale.clamp = function (v) {
    // eslint-disable-next-line no-sequences
    return v ? ((clamp = v), scale) : clamp;
  };
  return scale;
}

const colors = [
  ['124, 202, 242', '176, 223, 247'],
  ['38, 135, 255', '125, 183, 255'],
  ['71, 104, 232', '145, 164, 241'],
];
const colorSize = colors.length;
function getEpochColor(epochNum) {
  return colors[Math.ceil(epochNum) % colorSize];
}

const getEpochSpeed = scaleLinear()
  .domain([MAX_BUFFER_SIZE, MIN_BUFFER_SIZE])
  // 2 epochs/s <==> 1/30 epoch/frame
  .range([1.2, 0.5].map(x => x / 40))
  .clamp(true);

const INIT_WIDTH = INIT_EPOCH_WIDTH;
const MIDDLE_MARGIN = MAX_PIVOT_R;
const BORDER_MARGIN = MAX_NON_PIVOT_R;

function layout({ n, d, h: height, w = INIT_WIDTH }) {
  let points = [];
  let hit = 0;
  while (points.length <= n) {
    const _x = Math.random() * w;
    const _y =
      Math.random() > 0.5
        ? randomNumber(BORDER_MARGIN, height / 2 - MIDDLE_MARGIN)
        : randomNumber(height / 2 + MIDDLE_MARGIN, height - BORDER_MARGIN);
    let push = true;

    for (let i = 0; i < points.length; i++) {
      const [x, y] = points[i];

      if (Math.sqrt((x - _x) * (x - _x) + (y - _y) * (y - _y)) > d);
      else {
        push = false;
        hit++;
      }
    }

    if (hit > 5) {
      points = [];
      w += MAX_PIVOT_R;
      hit = 0;
    }

    if (push) {
      points.push([_x, _y]);
    }
  }
  return {
    points: points.map(([x, y]) => [x + MAX_PIVOT_R, y]),
    width: w + MAX_PIVOT_R * 3,
  };
}

function randomNumber(min, max) {
  return Math.random() * (max - min) + min;
}

function subscribe(height, cb) {
  let epochs = [];
  //allow only one pending request, the order is pretty unpredictable otherwise
  let sendNextRequest = true;

  function updateData() {
    if (sendNextRequest) {
      sendNextRequest = false;
      fetch('/v1/dag')
        .then(e => e.json())
        .then(({ list }) => {
          const _epochs = list.map(epoch => {
            const _epoch = {};
            let [pivot, ...rest] = epoch;
            const { epochNumber, ...pivotInfo } = pivot;
            //data from server can be wrong
            rest = rest.filter(d => d.epochNumber === epochNumber);
            _epoch.epochNumber = epochNumber;
            _epoch.colors = getEpochColor(epochNumber);
            _epoch.points = [];
            const { points, width } = layout({
              n: rest.length,
              d: 30,
              h: height,
            });

            //pivot
            _epoch.points.push({
              offsetX: width,
              y: height / 2,
              ...pivotInfo,
            });
            rest.forEach((block, i) => {
              const p = points[i];
              _epoch.points.push({
                offsetX: p[0],
                y: p[1],
                ...block,
              });
            });
            return _epoch;
          });
          sendNextRequest = true;
          cb((epochs = concat(_epochs, epochs)));
        })
        .catch(() => {
          sendNextRequest = true;
        });
    }
  }

  //update on subscribe
  updateData();

  const interval = setInterval(updateData, 5000);
  return () => {
    clearInterval(interval);
  };
}

function concat(newEpochs, oldEpochs) {
  if (oldEpochs.length === 0) {
    return newEpochs;
  }
  const oldInNew = newEpochs[newEpochs.length - 1].epochNumber;
  const newInOld = oldEpochs[0].epochNumber;
  const overlap = newInOld - oldInNew;
  if (overlap < 0);
  else {
    oldEpochs = oldEpochs.slice(overlap + 1);
  }
  const result = newEpochs.concat(oldEpochs);
  return result;
}

const MAX_PIVOT_R$1 = PIVOT_R[1];
const MAX_NON_PIVOT_R$1 = NON_PIVOT_R[1];

const staggering = 1;
const blinkScale = scaleLinear().domain([0, 1]).range([0, Math.PI]);
const lineScale = scaleLinear().domain([0, 1]).range([0, 1]).clamp(true);
const pivotOuterR = scaleLinear()
  .domain([
    INIT_EPOCH_WIDTH + MAX_PIVOT_R$1 * 3,
    INIT_EPOCH_WIDTH + MAX_PIVOT_R$1 * 5,
  ])
  .range(PIVOT_R)
  .clamp(true);
const PIVOT_OUTER_ALPHA = 0.3;
const { devicePixelRatio } = window;

function createRender(container, width, height) {
  //main canvas
  const canvas = document.createElement('canvas');
  canvas.width = width * devicePixelRatio;
  canvas.height = height * devicePixelRatio;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';

  container.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  ctx.scale(devicePixelRatio, devicePixelRatio);

  //hit canvas is detatched from dom
  const hitCanvas = document.createElement('canvas');
  hitCanvas.width = width;
  hitCanvas.height = height;
  const ctxHit = hitCanvas.getContext('2d', {
    preserveDrawingBuffer: true,
    antialias: false,
  });
  // ctxHit.imageSmoothingEnabled = false;

  return function render({ epochsToRender, growingEpoch, growingRate, x, y }) {
    let hoveredBlock;
    if (x && y) {
      const [, g, b, a] = ctxHit.getImageData(x, y, 1, 1).data;
      if (a === 255) {
        hoveredBlock = [g, b];
      } else {
        hoveredBlock = false;
      }
    }
    let tooptip;

    const hash2Point = {};

    const drawEdges = [];
    const drawPoints = [];
    let drawHover = [];

    epochsToRender.forEach((epoch, i) => {
      const { epochX, points, colors, epochNumber } = epoch;
      const isGrowingEpoch = growingEpoch === epochNumber;
      const isBlinkingEpoch = growingEpoch - 1 === epochNumber;
      const nPoints = points.length;

      // debugger
      points.forEach((point, j) => {
        const { offsetX, y, hash, parentHash, refereeHashes } = point;
        const x = epochX + offsetX;
        hash2Point[hash] = [x, y];
        const isPivot = j === 0;
        let pivotR;
        if (isPivot) {
          pivotR = pivotOuterR(offsetX);
        }
        const referees =
          hoveredBlock &&
          hoveredBlock[0] === i &&
          hoveredBlock[1] === j &&
          refereeHashes.map(hash => {
            return [hash, hash2Point[hash]];
          });

        let parentPoint;
        let alpha = 1;

        if (!(parentPoint = hash2Point[parentHash])) {
          parentPoint = [-200, height / 2];
        }

        const domainStart = (j / nPoints) * staggering;
        lineScale.domain([domainStart, 1]);
        const _growing = isGrowingEpoch ? lineScale(growingRate) : 1;

        drawEdges.push(() => {
          ctx.beginPath();
          const [parentX, parentY] = parentPoint;
          ctx.moveTo(parentX, parentY);
          const distX = parentX + (x - parentX) * _growing;
          const distY = parentY + (y - parentY) * _growing;
          ctx.lineTo(distX, distY);
          ctx.strokeStyle = `rgba(208, 215, 235,${alpha})`;
          ctx.lineWidth = isPivot ? 4 : 1;
          ctx.stroke();
        });

        drawPoints.push(() => {
          ctxHit.beginPath();
          ctxHit.fillStyle = `rgb(0,${i},${j})`;
          // encodeRgb(encode(i, j));
          ctxHit.arc(
            x,
            y,
            isPivot ? pivotR : MAX_NON_PIVOT_R$1,
            0,
            Math.PI * 2,
          );
          ctxHit.fill();
          if (!isGrowingEpoch) {
            let blinkingAlpha;
            if (isBlinkingEpoch) {
              blinkingAlpha = isPivot
                ? PIVOT_OUTER_ALPHA + Math.sin(blinkScale(growingRate)) * 0.4
                : alpha - Math.abs(Math.sin(blinkScale(growingRate))) * 0.6;
            }
            if (isPivot) {
              const pivotR = pivotOuterR(offsetX);
              ctx.beginPath();
              ctx.fillStyle = `rgba(${colors[0]},${blinkingAlpha || 0.3} )`;
              ctx.arc(x, y, pivotR, 0, Math.PI * 2);
              ctx.fill();

              ctx.beginPath();
              ctx.fillStyle = `rgba(${colors[0]}, 1)`;
              ctx.arc(x, y, pivotR * 0.7, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.beginPath();
              ctx.clearRect(
                x - MAX_NON_PIVOT_R$1,
                y - MAX_NON_PIVOT_R$1,
                MAX_NON_PIVOT_R$1 * 2,
                MAX_NON_PIVOT_R$1 * 2,
              );
              ctx.fillStyle = `rgba(${colors[1]}, ${blinkingAlpha || 1})`;
              ctx.arc(x, y, MAX_NON_PIVOT_R$1, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        });
        if (referees) {
          tooptip = {};
          const drawText = [];
          drawText.push(
            'Ref block hashes: ' + (referees.length === 0 ? '--' : ''),
          );

          const unfoundYGap = height / referees.length;
          let unfoundY = 0;

          referees.forEach(([hash, [_x, _y] = [-200, unfoundY]], i) => {
            unfoundY += unfoundYGap;
            drawHover.push(() => {
              ctx.beginPath();
              ctx.moveTo(_x, _y);
              ctx.lineTo(x, y);
              ctx.save();
              ctx.lineWidth = 1;
              ctx.setLineDash([3, 3]);
              ctx.stroke();
              ctx.restore();
            });
            const txt = `[${i}]:${hash}`;
            drawText.push(txt);
          });

          tooptip.position = [x, y];
          tooptip.hash = hash;
          tooptip.txt = drawText;
        }
      });
    });

    ctx.clearRect(0, 0, width, height);
    ctxHit.clearRect(0, 0, width, height);
    drawEdges.forEach(f => f());

    drawHover.forEach(f => f());
    drawPoints.forEach(f => f());

    return tooptip;
  };
}

function dag({ container }) {
  const { clientWidth: width, clientHeight: height } = container;
  const _container = document.createElement('div');
  _container.style.height = '100%';
  _container.style.position = 'relative';
  container.appendChild(_container);

  const tooptip = document.createElement('div');
  tooptip.style.backgroundColor = 'white';
  tooptip.style.position = 'absolute';
  tooptip.style.transition = '80ms';
  tooptip.style.padding = '5px';
  tooptip.style.whiteSpace = 'pre-line';
  tooptip.style.lineHeight = '15px';
  tooptip.style.cursor = 'unset';
  tooptip.style.display = 'none';

  _container.appendChild(tooptip);

  const render = createRender(_container, width, height);

  let epoches = [];
  let hoverCanvas;
  const unsubscribe = subscribe(height, _data => {
    epoches = _data;
  });

  let epochsToRender = [];
  let diff;
  let growthSpeed;
  let targetLeftMovingWidth = 0;
  let currentLeftMovingWidth = 0;
  let growingRate = 0;
  let growingEpoch;
  let isMoving;
  let currentEpoch;

  function addEpoch() {
    let bufferSize = epoches.length;
    //too much buffer to go mainly because hover or inactive
    if (bufferSize > MAX_BUFFER_SIZE) {
      while (epoches.length > MIN_BUFFER_SIZE) {
        if (
          epochsToRender[epochsToRender.length - 1].epochNumber <
          epoches[epoches.length - 1].epochNumber
        ) {
          epochsToRender.push(epoches.pop());
        }
      }
    }
    //the epoches may contain data already in the queue
    while (
      epochsToRender.length > 0 &&
      epoches.length > 0 &&
      epochsToRender[epochsToRender.length - 1].epochNumber >=
        epoches[epoches.length - 1].epochNumber
    ) {
      epoches.pop();
    }

    if (epoches.length > 0) {
      epochsToRender.push((currentEpoch = epoches.pop()));
    }

    bufferSize = epoches.length;
    growthSpeed = getEpochSpeed(bufferSize);

    //clean up epochsToRender for sake of memory
    if (epochsToRender.length > RENDER_SIZE && !hoverCanvas) {
      epochsToRender = epochsToRender.slice(
        epochsToRender.length - RENDER_SIZE,
      );
    }

    growingEpoch = currentEpoch.epochNumber;
    growingRate = 0;

    let currentEpochX;
    for (let i = 0; i < epochsToRender.length; i++) {
      const epoch = epochsToRender[i];
      let { epochX } = epoch;

      if (i === 0) {
        currentEpochX = epochX || 0;
      }
      const { points } = epoch;
      if (epochX === undefined) {
        epochX = epoch.epochX = currentEpochX;
      }
      currentEpochX = epochX + points[0].offsetX + MAX_PIVOT_R * 2;
      diff = currentEpochX - width;
    }

    //stop moving the whole canvas when hovering
    if (diff > 0 && !hoverCanvas) {
      targetLeftMovingWidth = diff;
      currentLeftMovingWidth = 0;
      for (let i = 0; i < epochsToRender.length; i++) {
        const epoch = epochsToRender[i];
        epoch._epochX = epoch.epochX;
      }
    }
  }

  function moveViewport() {
    currentLeftMovingWidth += 20;
    for (let i = 0; i < epochsToRender.length; i++) {
      const epoch = epochsToRender[i];
      epoch.epochX = epoch._epochX - currentLeftMovingWidth;
    }
  }

  let rafId;

  let hoveredBlock;
  let hoverTooltip;
  let x, y;
  let tooptipData;
  function loop() {
    const start = epoches.length > 0;
    if (start) {
      while (
        epochsToRender.length === 0 ||
        (epochsToRender[epochsToRender.length - 1].epochX < width / 2 &&
          epoches.length > 0)
      ) {
        addEpoch();
      }
      isMoving = currentLeftMovingWidth < targetLeftMovingWidth;
      const isGrowing = growingRate <= 1;
      //moving animation in order to making room for growing
      //and growing animation
      if (!isMoving && !isGrowing) {
        //no animation ready to play
        //add another block and trigger new circle
        addEpoch();
      } else if (isMoving) {
        moveViewport();
      } else if (isGrowing) {
        growingRate += growthSpeed;
      }
    }
    tooptipData = render({
      epochsToRender,
      growingEpoch,
      growingRate,
      x,
      y,
    });

    rafId = requestAnimationFrame(loop);
  }
  loop();

  let timer;
  let updateTooptip;
  function mousemove(e) {
    hoverCanvas = true;
    const { layerX, layerY } = e;
    x = layerX;
    y = layerY;
    tooptip.innerHTML = '';
    if (timer) {
      clearTimeout(timer);
    }
    if (tooptipData) {
      const { position, txt, hash } = tooptipData;
      hoveredBlock = hash;
      _container.style.cursor = 'pointer';
      updateTooptip = () => {
        const [p_x, p_y] = position;
        tooptip.style.display = 'block';
        tooptip.innerHTML = '';

        txt.forEach((line, i) => {
          const node = document.createElement('span');
          node.innerHTML = line;
          if (i === 0) {
            node.style.font = TITLE_FONT;
          } else {
            node.style.font = TXT_FONT;
          }
          node.style.display = 'block';
          tooptip.appendChild(node);
        });
        tooptip.style.visibility = 'hidden';
        const { clientWidth } = tooptip;
        tooptip.style.transform = `translate(${Math.max(
          0,
          Math.min(p_x - clientWidth * 0.2, width - clientWidth),
        )}px, ${p_y + 10}px)`;
        tooptip.style.visibility = 'visible';
      };
    } else {
      _container.style.cursor = '';
      hoveredBlock = '';
      timer = setTimeout(() => {
        if (!hoverTooltip) {
          updateTooptip = () => {
            tooptip.style.display = 'none';
          };
          updateTooptip();
        }
      }, 80);
    }
    if (updateTooptip) {
      updateTooptip();
    }
  }
  _container.addEventListener('mousemove', mousemove);

  function click() {
    if (hoveredBlock) {
      window.open('/block/' + hoveredBlock, '_blank');
    }
  }

  function mouseLeave() {
    hoverCanvas = false;
    //it can be leave canvas directly
    hoverTooltip = false;
    growingRate = 1; //trigger animation immediately
  }
  _container.addEventListener('mouseleave', mouseLeave);
  _container.addEventListener('click', click);

  function moveOnTooltip() {
    hoverTooltip = true;
  }
  function leaveTooltip() {
    hoverTooltip = false;
  }
  tooptip.addEventListener('mousemove', moveOnTooltip);
  tooptip.addEventListener('mouseleave', leaveTooltip);

  return function destory() {
    unsubscribe();
    window.cancelAnimationFrame(rafId);
    tooptip.removeEventListener('mousemove', moveOnTooltip);
    _container.removeEventListener('mousemove', mousemove);
    _container.removeEventListener('mouseleave', mouseLeave);
    _container.removeEventListener('click', click);
    container.innerHTML = '';
  };
}

export default dag;
